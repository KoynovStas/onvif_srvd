#	typemap.dat

#	Use this file to define XML namespace prefixes and type bindings for
#	interface header files generated by the wsdl2h tool.
#
#	This typemap.dat file is the default file used by wsdl2h to customize
#	its output. You can use wsdl2h option -t to specify an alternate file.

#######	XML NAMESPACE BINDINGS

#	You can define XML namespace prefix bindings to override the default
#	choice of the ns1, ns2, ... prefixes generated by wsdl2h.  It is highly
#	recommended to provide namespace prefixes for your project's XML
#	namespaces.  In this way, changes to the WSDL (or newer releases of
#	wsdl2h) will have a minimal impact on coding and project maintenance.
#
#	Bindings for namespace prefixes are of the form:
#
#		prefix = "URI"
#
#	For example, to bind prefix s3 to the AWS S3 namespace:
#
#		s3 = "http://s3.amazonaws.com/doc/2006-03-01/"

#######	XSD TYPE BINDINGS

#	Type bindings can be provided to bind XML schema types to C/C++
#	types for your project.
#
#	Type bindings are of the form:
#
#		prefix__type = declaration | use | ptr-use
#
#	where 'prefix__type' is the C/C++-translation of the schema type,
#	'declaration' introduces the type in the header file, the optional
#	'use' specifies how the type is used directly, and the optional
#	'ptr-use' specifies how the type is used as a pointer type.
#
#	For example, to use wide strings in C:
#
#		xsd__string = | wchar_t* | wchar_t*
#
#	this replaces the default char* mapping in C for xsd:string.
#	To use C++ std::wstring for xsd:string:
#
#		xsd__string = | std::wstring
#
#	After enabling one of these lines, all XSD strings will be changed in
#	the interface file generated by wsdl2h.  Rerun wsdl2h if necessary.
#	Note that the 'declaration' part above is empta,y as expected.
#
#	When a type binding requires only the usage to be changed and the
#	declaration part must be kept intact, then the declaration part should
#	be specified as an elipsis '...':
#
#		prefix__type = ... | use | ptr-use
#
#	This ensure that the wsdl2h-generated type definition is preserved,
#	while the use and ptr-use are changed.
#
#	For example, this is useful to map schema polymorphic types to C types,
#	where we need to be able to both handle a base type and its extensions
#	as per schema extensibility. Say base type ns:base allows derived
#	extensions and we need to map this to C types as follows:
#
#		ns__base = ... | int __type_base; void*
#
#	where __type_base and void* are used to (de)serialize any data type,
#	including base and its derived types.

#######	CLASS/STRUCT MEMBER ADDITIONS

#	Additional data and function members can be provided to extend a
#	wsdl2h-generated struct or class.
#
#	Class and struct extensions are of the form:
#
#		prefix__type = $ member-declaration
#
#	For example, to add a constructor and destructor to class myns__record:
#
#		myns__record = $ myns__record();
#		myns__record = $ ~myns__record();

#######	TYPE EQUIVALENCES

#	Type equivalence mappings can be given to replace a type with another:
#
#		prefix__type1 == prefix__type2
#
#	This replaces 'prefix__type1' by 'prefix__type2' in the wsdl2h output.
#
#	For example:
#
#		SOAP_ENC__boolean == xsd__boolean
#
#	replaces 'SOAP_ENC__boolean' with the C/C++ type information that
#	corresponds to `xsd__boolean' which is 'bool' for C++.
#
#	Target C/C++ type names (names without prefix) can also be replaced:
#
#		float == double
#
#	which replaces all 'float' with 'double' in the wsdl2h output. Beware
#	that replacing types may lead to xsi:type mismatches and SOAP
#	encoding id-ref mismatches when parsing inbound XML messages.

#######	BUILT-IN VARIABLES

#	The variable '$CONTAINER' defines the container to emit in the
#	generated declarations, which is std::vector by default.
#
#	For example:
#
#		$CONTAINER = std::list
#
#	The variable '$POINTER' defines the smart pointer to emit in the
#	generated declarations, replacing '*'. For example:
#
#		$POINTER = std::shared_ptr
#
#	Not all pointers in the generated output can be replaced by smart
#	pointers when standard pointers are used as union members and pointers
#	to arrays.

#######	USER-DEFINED CONTENT

#	Any other content to be included in the generated header file can be
#	provided by enclosing it within brackets [ and ]. These brackets MUST
#	appear at the start of a new line.
#
#	For example, to add an #import directive to the wsdl2h-generated output:
#
#       [
#       #import "wsa5.h"
#       ]

#-------------------------------------------------------------------------------
#gSOAP XML Web services tools
#Copyright (C) 2000-2015, Robert van Engelen, Genivia Inc. All Rights Reserved.
#This software is released under one of the following two licenses:
#GPL or Genivia's license for commercial use.
#-------------------------------------------------------------------------------
#A commercial use license is available from Genivia, Inc., contact@genivia.com
#-------------------------------------------------------------------------------

[
// Reminder: Modify typemap.dat to customize the header file generated by wsdl2h
]

#	Remember: type bindings are given on a single line (use \ to continue
#	with the next line). Here is an example binding for the XSD int type
#	that maps to an 'int':
# xsd__int	= | int

#	To use regular char* strings instead of std::string, use:
# xsd__string	= | char* | char*

#	For char* serialized with xsi:type when using soapcpp2 option -t, use:
# xsd__string	= typedef char *xsd__string; | xsd__string | xsd__string

#	The following mapping is internally applied by wsdl2h for C (not C++):
#	(assuming option -e is used to remove the xsd__boolean__ name prefix)
# xsd__boolean	= enum xsd__boolean { false_, true_ }; | enum xsd__boolean

#	Uncomment the line below to use __int128_t for xsd:integer instead of
#	mapping xsd:integer to string.
#	Then rerun wsdl2h and also compile and link custom/int128.c
# xsd__integer = #import "custom/int128.h" | xsd__integer
#
#	Or if the xsd:integer value range is bounded to int64_t, then:
# xsd__integer = typedef LONG64 xsd__integer;
#
#	Also, to enable XSD integer types that are restrictions of xsd:integer
#	to be mapped to int128 or LONG64, uncomment:
# xsd__nonNegativeInteger = typedef xsd__integer xsd__nonNegativeInteger 0 :   ;
# xsd__nonPositiveInteger = typedef xsd__integer xsd__nonPositiveInteger   : 0 ;
# xsd__positiveInteger    = typedef xsd__integer xsd__positiveInteger    1 :   ;
# xsd__negativeInteger    = typedef xsd__integer xsd__negativeInteger      : -1;

#	Uncomment the line below to use long double for xsd:decimal instead of
#	mapping xsd:decimal to string.
#	Then rerun wsdl2h and also compile and link custom/long_double.c.
# xsd__decimal = #import "custom/long_double.h" | long double
#
#	Or if your system supports __float128 then you can use:
# xsd__decimal = #import "custom/float128.h" | xsd__decimal
#
#	Or if the xsd:decimal value range is bounded to double, then:
# xsd__decimal = typedef double xsd__decimal;

#	Uncomment the line below to use struct tm instead of time_t xsd:dateTime
#	Then rerun wsdl2h and also compile and link custom/struct_tm.c.
# xsd__dateTime = #import "custom/struct_tm.h" | xsd__dateTime

#	Uncomment the line below to use timeval with usec precision xsd:dateTime
#	Then rerun wsdl2h and also compile and link custom/struct_timeval.c.
# xsd__dateTime = #import "custom/struct_timeval.h" | xsd__dateTime

#	Uncomment the line below to use std::chrono::system_clock::time_point
#	for xsd:dateTime.
#	Then rerun wsdl2h and also compile and link custom/chrono_time_point.c.
# xsd__dateTime = #import "custom/chrono_time_point.h" | xsd__dateTime

#	Uncomment the line below to use struct tm for xsd:date instead of
#	mapping xsd:date to string.
#	Then rerun wsdl2h and also compile and link custom/struct_tm_date.c.
# xsd__date = #import "custom/struct_tm_date.h" | xsd__date

#	Uncomment the line below to use LONG64 int for xsd:duration instead of
#	mapping xsd:duration to string (in milliseconds precision).
#	Then rerun wsdl2h and also compile and link custom/duration.c.

xsd__duration = #import "custom/duration.h" | xsd__duration

#	Uncomment the line below to use C++11 std::chrono::nanoseconds for
#	xsd:duration instead of mapping xsd:duration to string.
#	Then rerun wsdl2h and also compile and link custom/chrono_duration.cpp.
# xsd__duration = #import "custom/chrono_duration.h" | xsd__duration

#	Uncomment the line below to use ULONG64 int for xsd:time instead of
#	mapping xsd:time to string (also comes with high usec precision)
#	Then rerun wsdl2h and also compile and link custom/time.c
# xsd__time = #import "custom/long_time.h" | xsd__time

#	When compiling WITH_LEAN there is no hexBinary serializer. You can
#	remap the hexBinary type to a string as follows:
# xsd__hexBinary = | char*

#	When wsdl2h option -d is used, xsd:any is mapped to xsd__anyType DOM
#	declared in dom.h and implemented in dom.c/dom.cpp. You can remap
#	xsd:any, for example to a pointer to a DOM node as follows:
# xsd__any = | xsd__anyType*

#	When SOAP 1.2 Faults should carry multiple SOAP_ENV__Text elements with
#	xml:lang attributes, then remap SOAP_ENV__Reason as follows:
# [
# struct SOAP_ENV__Reason
# {
#   char *SOAP_ENV__Text; // at least one SOAP-ENV:Text for the gSOAP engine
#   $int size;
#   struct SOAP_ENV__Text *SOAP_ENV__Text_; // array of more SOAP-ENV:Text
# }; 
# struct SOAP_ENV__Text
# {
#   char *__item;
#   @char *xml__lang;
# };
# ]

#	SOAP-ENV mapping (note: SOAP Body content is mapped to an XML string)

SOAP_ENV__Envelope	= struct SOAP_ENV__Envelope { struct SOAP_ENV__Header *SOAP_ENV__Header; _XML SOAP_ENV__Body; }; | struct SOAP_ENV__Envelope
SOAP_ENV__Header	= | struct SOAP_ENV__Header
SOAP_ENV__Fault		= | struct SOAP_ENV__Fault
SOAP_ENV__Detail	= | struct SOAP_ENV__Detail
SOAP_ENV__Code		= | struct SOAP_ENV__Code
SOAP_ENV__Subcode	= | struct SOAP_ENV__Subcode
SOAP_ENV__Reason	= | struct SOAP_ENV__Reason

#	Temporary URI

tempuri	= "http://tempuri.org/"

#	Empty URI

empty	= ""

#	.NET WCF DataContract Serialization Schema

ser	= <http://schemas.microsoft.com/2003/10/Serialization/>
arr	= "http://schemas.microsoft.com/2003/10/Serialization/Arrays"

#	.NET WCF DataContract Serialization Schema remappings

_ser__anyURI		== xsd__anyURI
_ser__boolean		== xsd__boolean
_ser__base64Binary	== xsd__base64Binary
_ser__byte		== xsd__byte
_ser__dateTime		== xsd__dateTime
_ser__decimal		== xsd__decimal
_ser__double		== xsd__double
_ser__float		== xsd__float
_ser__int		== xsd__int
_ser__long		== xsd__long
_ser__QName		== xsd__QName
_ser__short		== xsd__short
_ser__string		== xsd__string
_ser__unsignedByte	== xsd__unsignedByte
_ser__unsignedInt	== xsd__unsignedInt
_ser__unsignedLong	== xsd__unsignedLong
_ser__unsignedShort	== xsd__unsignedShort

#	.NET WCF ser:anyType represents an object (see import/ser.h):

_ser__anyType	= | struct __ser__anyType | struct __ser__anyType

#	.NET WCF ser:char element and type represents a Unicode character

_ser__char	= | int
ser__char	= | int

#	.NET WCF ser:duration element and type maps to xsd:duration

_ser__duration	== xsd__duration
ser__duration	== xsd__duration

#	.NET WCF ser:guid pattern = "[\da-fA-F]{8}-[\da-fA-F]{4}-[\da-fA-F]{4}-[\da-fA-F]{4}-[\da-fA-F]{12}"

_ser__guid	= | char*
ser__guid	= | char*

#	.NET WCF samples

mssamh	= "http://Microsoft.Samples.Http"
mssamhi	= "http://Microsoft.Samples.Http/Imports"

mssamt	= "http://Microsoft.Samples.TransportSecurity"
mssamti	= "http://Microsoft.Samples.TransportSecurity/Imports"

mssamm	= "http://Microsoft.Samples.MessageSecurity"
mssammi	= "http://Microsoft.Samples.MessageSecurity/Imports"

mssadh  = "http://Microsoft.Samples.DualHttp"
mssadhi = "http://Microsoft.Samples.DualHttp/Imports"

#	MTOM xop and xmime are imported from xop.h, xmime.h, and xmlmime.h:
#	Note: changed xmlmime to xmime to avoid other MTOM tools from
#	complaining that 'xml' is reserved.

xop	= <http://www.w3.org/2004/08/xop/include>
xmime	= <http://www.w3.org/2004/06/xmlmime>
xmime4	= <http://www.w3.org/2004/11/xmlmime>
xmime5  = <http://www.w3.org/2005/05/xmlmime>

#	xop:Include is imported from xop.h and redefined as _xop__Include:

xop__Include = #import "xop.h" | _xop__Include

#	xmime/xmlmime:contentType attribute is a string:

_xmime__contentType	= | char* | char*
_xmime4__contentType	= | char* | char*
_xmime5__contentType	= | char* | char*

#	exc-c14n

c14n	= <http://www.w3.org/2001/10/xml-exc-c14n#>

#	WS-Addressing (2003, 2004, and 2005 schemas)
#	See import/wsa.h, import/wsa3.h etc for definitions and code examples
#	The API is defined in plugin/wsaapi.c, plugin/wsaapi3.c, etc.

wsa	= <http://schemas.xmlsoap.org/ws/2004/08/addressing>
wsa3	= <http://schemas.xmlsoap.org/ws/2003/03/addressing>
wsa4	= <http://schemas.xmlsoap.org/ws/2004/03/addressing>
wsa5	= <http://www.w3.org/2005/08/addressing>

#	The types below should not use pointers, so we add a 3rd column:

_wsa__Action    = | | _wsa__Action
_wsa__MessageID = | | _wsa__MessageID
_wsa__To        = | | _wsa__To

_wsa3__Action    = | | _wsa3__Action
_wsa3__MessageID = | | _wsa3__MessageID
_wsa3__To        = | | _wsa3__To

_wsa4__Action    = | | _wsa4__Action
_wsa4__MessageID = | | _wsa4__MessageID
_wsa4__To        = | | _wsa4__To

_wsa5__Action    = | | _wsa5__Action
_wsa5__MessageID = | | _wsa5__MessageID
_wsa5__To        = | | _wsa5__To

#	WS-ReliableMessaging 1.1 and 1.0 (and obsolete WS-Reliability 2004)

wsrm	= <http://docs.oasis-open.org/ws-rx/wsrm/200702>
wsrm5	= <http://schemas.xmlsoap.org/ws/2005/02/rm>
wsrm4	= <http://docs.oasis-open.org/wsrm/2004/06/ws-reliability-1.1.xsd>

#	WS-Discovery 1.1 (2009/01) and 1.0 (2004/08 with WS-Addressing)
#	To upgrade WS-Discovery to WS-Addressing 2005/08, uncomment wsdd5:

wsdd	= <http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01>
wsdd5	= <http://schemas.xmlsoap.org/ws/2005/04/discovery>
wsdd10	= <http://schemas.xmlsoap.org/ws/2005/04/discovery>

wsdd5__HelloType		= | wsdd__HelloType
wsdd5__ByeType			= | wsdd__ByeType
wsdd5__ProbeType		= | wsdd__ProbeType
wsdd5__ProbeMatchesType		= | wsdd__ProbeMatchesType
wsdd5__ProbeMatchType		= | wsdd__ProbeMatchType
wsdd5__ResolveType		= | wsdd__ResolveType
wsdd5__ResolveMatchesType	= | wsdd__ResolveMatchesType
wsdd5__ResolveMatchType		= | wsdd__ResolveMatchType
wsdd5__ScopesType		= | wsdd__ScopesType
wsdd5__SecurityType		= | wsdd__SecurityType
wsdd5__SigType			= | wsdd__SigType
wsdd5__AppSequenceType		= | wsdd__AppSequenceType

wsdd10__HelloType		= | wsdd__HelloType
wsdd10__ByeType			= | wsdd__ByeType
wsdd10__ProbeType		= | wsdd__ProbeType
wsdd10__ProbeMatchesType	= | wsdd__ProbeMatchesType
wsdd10__ProbeMatchType		= | wsdd__ProbeMatchType
wsdd10__ResolveType		= | wsdd__ResolveType
wsdd10__ResolveMatchesType	= | wsdd__ResolveMatchesType
wsdd10__ResolveMatchType	= | wsdd__ResolveMatchType
wsdd10__ScopesType		= | wsdd__ScopesType
wsdd10__SecurityType		= | wsdd__SecurityType
wsdd10__SigType			= | wsdd__SigType
wsdd10__AppSequenceType		= | wsdd__AppSequenceType

#	WS-Policy

wsp	= <http://schemas.xmlsoap.org/ws/2004/09/policy>

#	WS-SecureConversation 1.4

wsc	= <http://docs.oasis-open.org/ws-sx/ws-secureconversation/200512>
wsc2	= <http://schemas.xmlsoap.org/ws/2005/02/sc>

#	WS-Trust 1.2 and 1.3

wst	= <http://docs.oasis-open.org/ws-sx/ws-trust/200512/>
wst12	= <http://schemas.xmlsoap.org/ws/2005/02/trust>

#       SAML bindings

saml1   = <urn:oasis:names:tc:SAML:1.0:assertion>
saml2   = <urn:oasis:names:tc:SAML:2.0:assertion>

#	WS-Security wsse 2004 v1.0 and 1.1 and old wsse 2002 schema

wsse11	= <http://docs.oasis-open.org/wss/oasis-wss-wssecurity-secext-1.1.xsd>
wsse	= <http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd>
wsse2	= <http://schemas.xmlsoap.org/ws/2002/12/secext>

_wsse2__Security == _wsse__Security
wsse2__Security == wsse__Security

#	wsu 2004

wsu	= <http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd>

_wsu__Id		= | char*
_wsu__Created		= | time_t
_wsu__Expires		= | time_t

wsu__AttributedDateTime	= | time_t
wsu__AttributedURI	= | char*

#	Bindings for ds and xenc for WS-Security protocols:

ds	= <http://www.w3.org/2000/09/xmldsig#>
xenc	= <http://www.w3.org/2001/04/xmlenc#>

#	xlink

xlink	= "http://www.w3.org/1999/xlink"

#	wsrp routing protocol (deprecated)

wsrp	= <http://schemas.xmlsoap.org/rp/>

#	BPEL 2.0

bpel	= "http://docs.oasis-open.org/wsbpel/2.0/process/executable"
bpelabs = "http://docs.oasis-open.org/wsbpel/2.0/process/abstract"
plnk	= "http://docs.oasis-open.org/wsbpel/2.0/plnktype"
sref	= "http://docs.oasis-open.org/wsbpel/2.0/serviceref"
vprop	= "http://docs.oasis-open.org/wsbpel/2.0/varprop"

#	ONVIF recommended prefixes as per 8/20/12
#	http://www.onvif.org/onvif/ver10/device/wsdl/devicemgmt.wsdl
#	http://www.onvif.org/onvif/ver10/event/wsdl/event.wsdl
#	http://www.onvif.org/onvif/ver10/display.wsdl
#	http://www.onvif.org/onvif/ver10/deviceio.wsdl
#	http://www.onvif.org/onvif/ver20/imaging/wsdl/imaging.wsdl
#	http://www.onvif.org/onvif/ver10/media/wsdl/media.wsdl
#	http://www.onvif.org/onvif/ver20/ptz/wsdl/ptz.wsdl
#	http://www.onvif.org/onvif/ver10/receiver.wsdl
#	http://www.onvif.org/onvif/ver10/recording.wsdl
#	http://www.onvif.org/onvif/ver10/search.wsdl
#	http://www.onvif.org/onvif/ver10/network/wsdl/remotediscovery.wsdl
#	http://www.onvif.org/onvif/ver10/replay.wsdl
#	http://www.onvif.org/onvif/ver20/analytics/wsdl/analytics.wsdl
#	http://www.onvif.org/onvif/ver10/analyticsdevice.wsdl	
#	http://www.onvif.org/onvif/ver10/schema/onvif.xsd

tds	= <http://www.onvif.org/ver10/device/wsdl>
tev	= <http://www.onvif.org/ver10/events/wsdl>
tls	= <http://www.onvif.org/ver10/display/wsdl>
tmd	= <http://www.onvif.org/ver10/deviceIO/wsdl>
timg	= <http://www.onvif.org/ver20/imaging/wsdl>
trt	= <http://www.onvif.org/ver10/media/wsdl>
tptz	= <http://www.onvif.org/ver20/ptz/wsdl>
trv	= <http://www.onvif.org/ver10/receiver/wsdl>
trc	= <http://www.onvif.org/ver10/recording/wsdl>
tse	= <http://www.onvif.org/ver10/search/wsdl>
trp	= <http://www.onvif.org/ver10/replay/wsdl>
tan	= <http://www.onvif.org/ver20/analytics/wsdl>
tad	= <http://www.onvif.org/ver10/analyticsdevice/wsdl>
tdn	= <http://www.onvif.org/ver10/network/wsdl>
tt	= <http://www.onvif.org/ver10/schema>

#	OASIS recommended prefixes

wsnt	= <http://docs.oasis-open.org/wsn/b-2>
wsntw	= <http://docs.oasis-open.org/wsn/bw-2>
wsrfbf	= <http://docs.oasis-open.org/wsrf/bf-2>
wsrfr	= <http://docs.oasis-open.org/wsrf/r-2>
wsrfrw  = <http://docs.oasis-open.org/wsrf/rw-2>
wstop	= <http://docs.oasis-open.org/wsn/t-1>

#	Prefix bindings for WhiteMesa interoperability testing round 2:

i	= "http://soapinterop.org/"
s	= "http://soapinterop.org/xsd"

#	Prefix bindings for Amazon AWS S3 Web Services:

aws	= "urn:PI/DevCentral/SoapService"
s3	= "http://s3.amazonaws.com/doc/2006-03-01/"

_s3__CreateBucketResponse = $ s3__CreateBucketResult* CreateBucketResponse;
_s3__CopyObjectResponse   = $ s3__CopyObjectResult* CopyObjectResponse;

#	Prefix binding for Mappoint Web services:

mpt	= "http://s.mappoint.net/mappoint-30/"

#	Prefix binding for XLIFF 2.0

xliff = "urn:oasis:names:tc:xliff:document:2.0"

xliff__priorityValue = typedef int xliff__priorityValue 1:10;
